require("dotenv").config(); // Load .env variables
const express = require("express");
const cors = require("cors");
const Groq = require("groq-sdk");
const OpenAI = require("openai"); // Import OpenAI library
const http = require("http"); // Import http module
const { WebSocketServer } = require("ws"); // Import WebSocketServer
const sqlite3 = require('sqlite3').verbose(); // Import SQLite library
const path = require('path'); // Node.js path module for file paths
const { v4: uuidv4 } = require('uuid'); // For generating message IDs

const app = express();
const port = process.env.PORT || 3001;
const server = http.createServer(app); // Create HTTP server from Express app
const wss = new WebSocketServer({ server }); // Create WebSocket server

// --- Configuration ---
const groqApiKey = process.env.GROQ_API_KEY;
const localLlmApiEndpoint = process.env.LOCAL_LLM_API_ENDPOINT || "http://localhost:11434/v1"; // Default local endpoint
const useGroq = !!groqApiKey; // Determine which service to use

let llmClient; // Will hold either Groq or OpenAI client

// --- SQLite Database Setup ---
const dbPath = path.resolve(__dirname, 'project_zephyrine_chats.db'); // Database file in the same directory
console.log(`Attempting to connect to SQLite database at: ${dbPath}`);

const db = new sqlite3.Database(dbPath, sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE, (err) => {
  if (err) {
    console.error("FATAL ERROR: Could not connect to SQLite database.", err.message);
    process.exit(1); // Exit if DB connection fails
  }
  console.log(`Successfully connected to SQLite database: ${dbPath}`);
});

// Ensure required tables exist (run once on startup)
db.serialize(() => {
    // Enable WAL mode for better concurrency (optional but recommended)
    db.run("PRAGMA foreign_keys = ON;"); // Enforce foreign key constraints
    db.run("PRAGMA journal_mode = WAL;", (err) => {
        if (err) {
            console.error("Error setting PRAGMA journal_mode=WAL:", err.message);
        } else {
            console.log("SQLite journal_mode set to WAL.");
        }
    });

    // Create the 'chats' table if it doesn't exist
    db.run(`
        CREATE TABLE IF NOT EXISTS chats (
            id TEXT PRIMARY KEY NOT NULL,    -- Chat UUID
            user_id TEXT NOT NULL,           -- User identifier
            title TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    `, (err) => {
        if (err) {
            console.error("FATAL ERROR: Error creating 'chats' table:", err.message);
            process.exit(1); // Exit if table creation fails
        } else {
            console.log("Table 'chats' is ready.");
        }
    });

    // Create the 'messages' table if it doesn't exist
    db.run(`
        CREATE TABLE IF NOT EXISTS messages (
            id TEXT PRIMARY KEY NOT NULL,         -- Message UUID (generated by backend)
            chat_id TEXT NOT NULL,                -- Foreign key to chats table
            user_id TEXT NOT NULL,                -- User identifier
            sender TEXT NOT NULL CHECK(sender IN ('user', 'assistant')), -- 'user' or 'assistant'
            content TEXT NOT NULL,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (chat_id) REFERENCES chats(id) ON DELETE CASCADE
        )
    `, (err) => {
        if (err) {
            console.error("FATAL ERROR: Error creating 'messages' table:", err.message);
            process.exit(1);
        } else {
            console.log("Table 'messages' is ready.");
        }
    });
    // Add index for faster message retrieval by chat_id
    db.run("CREATE INDEX IF NOT EXISTS idx_messages_chat_id ON messages(chat_id);", (err) => {
         if (err) console.error("Error creating index on messages(chat_id):", err.message);
    });
});


// --- Initialize LLM Client ---
if (useGroq) {
  console.log("Using Groq API.");
  llmClient = new Groq({ apiKey: groqApiKey });
} else {
  console.log(`Using local OpenAI-compatible API at: ${localLlmApiEndpoint}`);
  llmClient = new OpenAI({
    baseURL: localLlmApiEndpoint,
    apiKey: process.env.LOCAL_LLM_API_KEY || "ollama",
  });
}

// --- Middleware ---
app.use(cors({ origin: "*" }));
app.use(express.json());

// --- Helper ---
// Format messages for LLM API
const formatMessagesForLLM = (messages) => {
  // Expects messages in the format { sender: 'user'/'assistant', content: '...' }
  return messages.map((msg) => ({
    role: msg.sender === "user" ? "user" : "assistant",
    content: msg.content,
  }));
};

// --- Database Interaction Helpers ---

// Saves a single message (user or assistant) to the DB
// Returns the saved message object with its DB ID or null on error
const saveMessageToDb = (messageData) => {
    return new Promise((resolve, reject) => {
        const { chatId, userId, sender, content } = messageData;
        if (!chatId || !userId || !sender || typeof content === 'undefined') {
            console.error("saveMessageToDb: Missing required fields.", messageData);
            return reject(new Error("Missing required fields for saving message."));
        }

        const messageId = uuidv4(); // Generate a unique ID for the message
        const sql = `INSERT INTO messages (id, chat_id, user_id, sender, content, created_at)
                     VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`;

        db.run(sql, [messageId, chatId, userId, sender, content], function(err) {
            if (err) {
                console.error(`Error saving ${sender} message to SQLite for chat ${chatId}:`, err.message);
                reject(err);
            } else {
                console.log(`${sender.charAt(0).toUpperCase() + sender.slice(1)} message saved (ID: ${messageId}) for chat ${chatId}.`);
                // Retrieve the saved message to return it with created_at timestamp
                db.get("SELECT * FROM messages WHERE id = ?", [messageId], (getErr, row) => {
                    if (getErr) {
                        console.error("Error retrieving saved message:", getErr.message);
                        reject(getErr); // Still reject, but log this specific error
                    } else {
                        resolve(row); // Resolve with the full message object from DB
                    }
                });
            }
        });
    });
};

// Updates a message's content in the DB
const updateMessageInDb = (messageId, newContent) => {
     return new Promise((resolve, reject) => {
        const sql = `UPDATE messages SET content = ?, created_at = CURRENT_TIMESTAMP WHERE id = ?`;
        db.run(sql, [newContent, messageId], function(err) {
            if (err) {
                console.error(`Error updating message ${messageId} in SQLite:`, err.message);
                reject(err);
            } else if (this.changes === 0) {
                console.warn(`Attempted to update message ${messageId}, but it was not found.`);
                reject(new Error("Message not found for update."));
            } else {
                console.log(`Message ${messageId} updated successfully.`);
                resolve(this.changes); // Resolve with number of rows affected
            }
        });
    });
};


// --- Title Generation Helper (Using SQLite) ---
const TITLE_PROMPT =
  "write a concise three word summary of the title based on the conversation and context below. ONLY THREE WORDS, NO OTHER EXPLANATION OR I WILL KILL YOU";

const generateAndSaveChatTitle = async (
  chatId,
  userId,
  wsClient,
  firstUserMessageContent,
  modelName
) => {
  if (!chatId || !userId || !firstUserMessageContent) {
    // Validation logic remains same
    return;
  }
  // Model name fallback remains same
  modelName = modelName || (useGroq ? "llama3-8b-8192" : "llama3");

  try {
    // LLM call remains same
    const groqMessages = [{ role: "system", content: TITLE_PROMPT }, { role: "user", content: firstUserMessageContent }];
    console.log(`Generating title for chat ${chatId} using model ${modelName}...`);
    const completion = await llmClient.chat.completions.create({
      messages: groqMessages, model: modelName, temperature: 0.5, max_tokens: 20, stream: false,
    });
    let generatedTitle = completion.choices[0]?.message?.content?.trim() || `Chat ${chatId.substring(0, 8)}`;
    generatedTitle = generatedTitle.replace(/["']/g, "");
    console.log(`Generated title for chat ${chatId}: "${generatedTitle}"`);

    // Save/Update title in SQLite 'chats' table
    const sql = `
        INSERT INTO chats (id, user_id, title, updated_at)
        VALUES (?, ?, ?, CURRENT_TIMESTAMP)
        ON CONFLICT(id) DO UPDATE SET
            title = excluded.title,
            user_id = excluded.user_id,
            updated_at = CURRENT_TIMESTAMP;
    `;
    db.run(sql, [chatId, userId, generatedTitle], function(err) {
        if (err) {
            console.error(`Error saving title to SQLite for chat ${chatId}:`, err.message);
        } else {
            console.log(`Successfully saved title for chat ${chatId} to SQLite. Rows affected: ${this.changes}`);
            if (wsClient && wsClient.readyState === wsClient.OPEN) {
                wsClient.send(JSON.stringify({ type: "title_updated", payload: { chatId: chatId, title: generatedTitle } }));
                console.log(`Sent title_updated confirmation for chat ${chatId}`);
            }
        }
    });
  } catch (error) {
    console.error(`Unexpected error during title generation/saving for chat ${chatId}:`, error);
  }
};

// --- WebSocket Handling ---
// Keep track of active streams per client connection if needed for complex scenarios,
// but for now, one stream per connection seems sufficient.
// Map to store active stream controllers/iterators if handling multiple concurrent streams per client becomes necessary.
// const activeStreams = new Map();

wss.on("connection", (ws) => {
  let currentStreamIterator = null; // Manage the async iterator for cancellation
  console.log("Client connected via WebSocket");

  ws.on("message", async (message) => {
    const messageString = message.toString();
    console.log("Received message:", messageString.substring(0, 200) + (messageString.length > 200 ? "..." : "")); // Log truncated message
    let requestData;

    try {
      requestData = JSON.parse(messageString);
    } catch (error) {
      console.error("Failed to parse incoming message:", error);
      ws.send(JSON.stringify({ type: "error", payload: { error: "Invalid message format. Expected JSON." } }));
      return;
    }

    // Cancel previous stream if a new actionable message arrives
    const cancelPreviousStream = () => {
        if (currentStreamIterator) {
            console.log("Cancelling previous stream due to new request.");
            currentStreamIterator = null; // Signal the loop to stop
        }
    };

    try { // Outer try-catch for message type handling
        switch (requestData.type) {

            // --- Get Chat History ---
            case "get_messages": {
                cancelPreviousStream(); // Cancel any ongoing generation
                const { chatId } = requestData.payload;
                if (!chatId) {
                    ws.send(JSON.stringify({ type: "chat_history_error", payload: { chatId, error: "Missing chat ID." } }));
                    return;
                }
                console.log(`Fetching messages for chat: ${chatId}`);
                db.all("SELECT * FROM messages WHERE chat_id = ? ORDER BY created_at ASC", [chatId], (err, rows) => {
                    if (err) {
                        console.error(`Error fetching messages for chat ${chatId}:`, err.message);
                        ws.send(JSON.stringify({ type: "chat_history_error", payload: { chatId, error: "Database error fetching messages." } }));
                    } else {
                        console.log(`Sending history for chat ${chatId} (${rows.length} messages)`);
                        ws.send(JSON.stringify({ type: "chat_history", payload: { chatId, messages: rows } }));
                    }
                });
                break;
            }

            // --- Handle New Chat Message / Regeneration ---
            case "chat": {
                cancelPreviousStream(); // Cancel previous generation if any
                const { messages: history, model, chatId, userId, firstUserMessageContent } = requestData.payload;

                // Validation
                if (!chatId || !userId || !history || !Array.isArray(history) || !model) {
                    ws.send(JSON.stringify({ type: "error", payload: { error: "Missing required fields in chat payload." } }));
                    return;
                }

                 // Identify and save the new user message (the last one in the history payload)
                let savedUserMessage = null;
                const latestMessage = history[history.length - 1];
                if (latestMessage && latestMessage.sender === 'user') {
                    try {
                        // Assume the last user message is the new one to be saved
                        savedUserMessage = await saveMessageToDb({
                            chatId,
                            userId,
                            sender: 'user',
                            content: latestMessage.content
                        });
                        // Optional: Send confirmation back
                        // ws.send(JSON.stringify({ type: "message_saved", payload: { id: savedUserMessage.id } }));
                    } catch (dbError) {
                         console.error("Failed to save user message before LLM call:", dbError);
                         ws.send(JSON.stringify({ type: "message_save_error", payload: { error: "Failed to save user message." } }));
                         return; // Stop processing if user message can't be saved
                    }
                }

                // Prepare for LLM call
                const formattedMsgs = formatMessagesForLLM(history);
                const activeModel = model;
                console.log(`Streaming response via WebSocket for model: ${activeModel}, chatId: ${chatId}`);

                // Initiate LLM Stream
                const stream = await llmClient.chat.completions.create({
                    messages: formattedMsgs, model: activeModel, temperature: 0.7, max_tokens: 1024, top_p: 1, stream: true,
                });
                currentStreamIterator = stream; // Store iterator for cancellation

                let assistantResponseContent = "";
                let assistantMessageId = null; // Will be generated when saving

                // Stream data back
                for await (const chunk of stream) {
                    if (!currentStreamIterator) { // Check for cancellation
                        console.log(`Stream processing stopped externally for chatId: ${chatId}`);
                        break;
                    }
                    const content = chunk.choices[0]?.delta?.content || "";
                    if (content) {
                        assistantResponseContent += content;
                        if (ws.readyState === ws.OPEN) {
                            ws.send(JSON.stringify({ type: "chunk", payload: { content } }));
                        } else {
                            console.log("WebSocket closed during streaming, stopping.");
                            currentStreamIterator = null; break;
                        }
                    }
                }

                // Stream finished or stopped
                if (currentStreamIterator && ws.readyState === ws.OPEN) { // Completed naturally
                    ws.send(JSON.stringify({ type: "end" }));
                    console.log(`Stream finished naturally for WebSocket client (chatId: ${chatId}).`);

                    // Save the complete assistant message
                    if (assistantResponseContent) {
                        try {
                            const savedAssistantMessage = await saveMessageToDb({
                                chatId,
                                userId, // Assistant message associated with the user of the chat
                                sender: 'assistant',
                                content: assistantResponseContent
                            });
                             // Optional confirmation
                            // ws.send(JSON.stringify({ type: "message_saved", payload: { id: savedAssistantMessage.id } }));
                        } catch (dbError) {
                             console.error("Failed to save assistant message after stream end:", dbError);
                             ws.send(JSON.stringify({ type: "message_save_error", payload: { error: "Failed to save assistant message." } }));
                        }
                    }

                    // Trigger Title Generation if needed
                    if (firstUserMessageContent) {
                        console.log(`First user message detected for chat ${chatId}, triggering title generation.`);
                        generateAndSaveChatTitle(chatId, userId, ws, firstUserMessageContent, activeModel);
                    }
                } else if (!currentStreamIterator) { // Was cancelled
                    console.log(`Stream cancelled for chatId: ${chatId}. Assistant response (partial): "${assistantResponseContent.substring(0, 50)}..."`);
                    // Optionally save the partial response here if needed
                    // If saving partial: saveMessageToDb({ chatId, userId, sender: 'assistant', content: assistantResponseContent });
                }

                currentStreamIterator = null; // Clear iterator reference
                break;
            }

            // --- Handle Edit Message and Regenerate ---
            case "edit_message": {
                 cancelPreviousStream(); // Cancel previous generation if any
                const { messageId, newContent, chatId, userId, historyForRegen, model } = requestData.payload;

                if (!messageId || typeof newContent === 'undefined' || !chatId || !userId || !historyForRegen || !model) {
                    ws.send(JSON.stringify({ type: "error", payload: { error: "Missing required fields in edit_message payload." } }));
                    return;
                }

                try {
                    // 1. Update the user message in the database
                    await updateMessageInDb(messageId, newContent);
                    // Send confirmation (optional)
                     // ws.send(JSON.stringify({ type: "message_updated", payload: { id: messageId } }));

                    // 2. Trigger regeneration (similar to 'chat' handler logic)
                    const formattedMsgs = formatMessagesForLLM(historyForRegen);
                    const activeModel = model;
                    console.log(`Regenerating response via WebSocket after edit for model: ${activeModel}, chatId: ${chatId}`);

                    const stream = await llmClient.chat.completions.create({
                        messages: formattedMsgs, model: activeModel, temperature: 0.7, max_tokens: 1024, top_p: 1, stream: true,
                    });
                    currentStreamIterator = stream;

                    let assistantResponseContent = "";

                    for await (const chunk of stream) {
                        if (!currentStreamIterator) { break; }
                        const content = chunk.choices[0]?.delta?.content || "";
                        if (content) {
                            assistantResponseContent += content;
                            if (ws.readyState === ws.OPEN) {
                                ws.send(JSON.stringify({ type: "chunk", payload: { content } }));
                            } else {
                                console.log("WebSocket closed during edit regeneration streaming, stopping.");
                                currentStreamIterator = null; break;
                            }
                        }
                    }

                    if (currentStreamIterator && ws.readyState === ws.OPEN) { // Completed naturally
                        ws.send(JSON.stringify({ type: "end" }));
                        console.log(`Edit regeneration finished naturally for chatId: ${chatId}.`);
                        // Save the new assistant message
                        if (assistantResponseContent) {
                            try {
                                await saveMessageToDb({ chatId, userId, sender: 'assistant', content: assistantResponseContent });
                                // Optional confirmation
                                // ws.send(JSON.stringify({ type: "message_saved", payload: { /* new assistant message id */ } }));
                            } catch (dbError) {
                                 console.error("Failed to save assistant message after edit regeneration:", dbError);
                                 ws.send(JSON.stringify({ type: "message_save_error", payload: { error: "Failed to save assistant response after edit." } }));
                            }
                        }
                    } else if (!currentStreamIterator) { // Was cancelled
                        console.log(`Edit regeneration stream cancelled for chatId: ${chatId}.`);
                        // Optionally save partial assistant response
                    }
                    currentStreamIterator = null;

                } catch (dbError) {
                    console.error(`Failed to update message ${messageId} or regenerate:`, dbError);
                    ws.send(JSON.stringify({ type: "message_update_error", payload: { error: `Failed to update message: ${dbError.message}` } }));
                    currentStreamIterator = null; // Ensure stream is cleared on DB error
                }
                break;
            }

            // --- Handle Stop Generation Request ---
            case "stop": {
                console.log("Received stop request from client.");
                if (currentStreamIterator) {
                    console.log("Signalling current stream to stop processing.");
                    currentStreamIterator = null; // Signal the active loop to stop
                    if (ws.readyState === ws.OPEN) {
                        ws.send(JSON.stringify({ type: "stopped" })); // Send confirmation
                    }
                } else {
                    console.log("No active stream to stop.");
                }
                break;
            }

            default:
                console.log(`Received unhandled message type: ${requestData.type}`);
                 if (ws.readyState === ws.OPEN) {
                     ws.send(JSON.stringify({ type: "error", payload: { error: `Unknown command: ${requestData.type}` } }));
                 }
        } // End switch
    } catch (handlerError) {
        console.error(`Error handling message type ${requestData?.type}:`, handlerError);
        currentStreamIterator = null; // Ensure stream is cancelled on handler error
        if (ws.readyState === ws.OPEN) {
            ws.send(JSON.stringify({ type: "error", payload: { error: `Internal server error handling command ${requestData?.type}.` } }));
        }
    } // End outer try-catch

  }); // End ws.on("message")

  ws.on("close", () => {
    console.log("Client disconnected");
    currentStreamIterator = null; // Clear stream reference on disconnect
  });

  ws.on("error", (error) => {
    console.error("WebSocket error:", error);
    currentStreamIterator = null; // Clear stream reference on error
  });
});


// --- Graceful Shutdown ---
const cleanup = (signal) => {
    console.log(`\n${signal} received. Closing server and SQLite database...`);
    wss.clients.forEach(client => {
        if (client.readyState === client.OPEN) { // Use ws constants if available
             client.close();
        }
    });
    server.close(() => {
        console.log("HTTP server closed.");
        db.close((err) => {
            if (err) {
                console.error('Error closing SQLite database:', err.message);
                process.exit(1);
            } else {
                console.log('SQLite database connection closed.');
                process.exit(0);
            }
        });
    });
    setTimeout(() => {
        console.error("Graceful shutdown timed out. Forcing exit.");
        process.exit(1);
    }, 5000);
};

process.on('SIGINT', () => cleanup('SIGINT'));
process.on('SIGTERM', () => cleanup('SIGTERM'));


// --- Start Server ---
server.listen(port, () => {
  const activeService = useGroq ? "Groq" : `Local LLM (${localLlmApiEndpoint})`;
  console.log(
    `Backend service (using ${activeService}, DB: SQLite @ ${dbPath}) with WebSocket listening on port ${port}`
  );
});